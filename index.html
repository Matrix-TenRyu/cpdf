<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprendendo L√≥gica de Programa√ß√£o com Linguagem C</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Aprendendo L√≥gica de Programa√ß√£o com Linguagem C</h1>
        <p>Um guia completo para iniciantes na programa√ß√£o</p>
    </header>

    <div class="chapter">
        <h2>Prop√≥sito da Linguagem C</h2>
        <p>A linguagem C √© uma das linguagens de programa√ß√£o mais importantes e influentes da hist√≥ria da computa√ß√£o.
            Foi criada em 1972 por Dennis Ritchie como sucessora da linguagem B e at√© hoje √© muito usada principalmente por estar na lista de linguagens mais r√°pidas do mundo.
        </p>
        
        <h3>Principais caracter√≠sticas:</h3>
        <ul>
            <li><strong>Linguagem de prop√≥sito geral</strong></li>
            <li>Efici√™nte</li>
            <li>C√≥digo executado de forma <strong>r√°pida</strong></li>
            <li><strong>Portabilidade:</strong> Pode ser compilada em diversas plataformas</li>
        </ul>
        
        <h3>Por que aprender C?</h3>
        <p><strong>C</strong> √© uma linguagem que, embora um pouco complexa para alguns, ainda assim possui todos as funcionalidades necess√°rias para que 
            uma pessoa possa aprender l√≥gica de programa√ß√£o.
            Esta √© a finalidade deste site. Te ensinar l√≥gica de programa√ß√£o de forma simples e tranquila.
        </p>
        <pre><code>#include &lt;stdio.h&gt;

int main() {
    printf("C √© a base para muitas linguagens modernas!\n");
    return 0;
}</code></pre>
    </div>
<div id="aviso">
    <h2>
        AVISO:
    </h2>
    <p>
        Mesmo que o material seja para ensinar de forma r√°pida e simples, n√£o quer dizer que voc√™ n√£o tenha que <strong>PRATICAR.</strong>
    </p>
    <p>
        <strong>PRATICAR</strong> √© uma fase importante do aprendizado. E n√£o deve ser negligenciada de nenhuma forma.
        <p>
            Ent√£o, se quer aprender realmente. <strong>PRATIQUE BASTANTE.</strong> Permita-se <strong>ERRAR.</strong>
            E, acima de tudo, <strong>N√ÉO DESISTA!!!</strong>
        </p>
    </p>
</div>
    <div class="nav">
        <h2>Sum√°rio</h2>
        <ul>
            <li><a href="#cap1">Cap√≠tulo 1 - Instala√ß√£o</a></li>
            <li><a href="#cap2">Cap√≠tulo 2 - Coment√°rios e sequ√™ncias de escape</a></li>
            <li><a href="#cap3">Cap√≠tulo 3 - Vari√°veis</a></li>
            <li><a href="#cap4">Cap√≠tulo 4 - Tipos de Dados</a></li>
            <li><a href="#cap5">Cap√≠tulo 5 - Especificadores de formata√ß√£o</a></li>
            <li><a href="#cap6">Cap√≠tulo 6 - Constantes</a></li>
            <li><a href="#cap7">Cap√≠tulo 7 - Operadores Aritim√©ticos</a></li>
            <li><a href="#cap8">Cap√≠tulo 8 - Operadores de Atribui√ß√£o Compostos</a></li>
            <li><a href="#cap9">Cap√≠tulo 9 - Entrada de Dados do Usu√°rio</a></li>
            <li><a href="#cap10">Cap√≠tulo 10 - Fun√ß√µes Matem√°ticas</a></li>
            <li><a href="#cap11">Cap√≠tulo 11 - Condi√ß√µes IF, ELSE IF e ELSE</a></li>
            <li><a href="#cap12">Cap√≠tulo 12 - Condi√ß√µes SWITCH, CASE e DEFAULT</a></li>
            <li><a href="#cap13">Cap√≠tulo 13 - Operador L√≥gico AND (&&)</a></li>
            <li><a href="#cap14">Cap√≠tulo 14 - Operador L√≥gico OR (||)</a></li>
            <li><a href="#cap15">Cap√≠tulo 15 - Operador L√≥gico NOT(!)</a></li>
            <li><a href="#cap16">Cap√≠tulo 16 - Fun√ß√µes</a></li>
            <li><a href="#cap17">Cap√≠tulo 17 - Argumentos</a></li>
            <li><a href="#cap18">Cap√≠tulo 18 - Condi√ß√£o RETURN</a></li>
            <li><a href="#cap19">Cap√≠tulo 19 - Operadores Tern√°rios (?, :)</a></li>
            <li><a href="#cap20">Cap√≠tulo 20 - Fun√ß√µes Prot√≥tipo</a></li>
            <li><a href="#cap21">Cap√≠tulo 21 - Fun√ß√µes String</a></li>
            <li><a href="#cap22">Cap√≠tulo 22 - Estrutura de Repeti√ß√£o FOR</a></li>
            <li><a href="#cap23">Cap√≠tulo 23 - Estrutura de Repeti√ß√£o WHILE</a></li>
            <li><a href="#cap24">Cap√≠tulo 24 - Estrutura DO, WHILE</a></li>
            <li><a href="#cap25">Cap√≠tulo 25 - Estruturas de Repeti√ß√£o Internas (Nested Loops)</a></li>
            <li><a href="#cap26">Cap√≠tulo 26 - BREAK vs CONTINUE</a></li>
            <li><a href="#cap27">Cap√≠tulo 27 - Arrays</a></li>
            <li><a href="#cap28">Cap√≠tulo 28 - Mostrando uma Array usando Estruturas de Repeti√ß√£o</a></li>
            <li><a href="#cap29">Cap√≠tulo 29 - Arrays 2D</a></li>
            <li><a href="#cap30">Cap√≠tulo 30 - Arrays de String</a></li>
            <li><a href="#cap31">Cap√≠tulo 31 - Trocar Valores Entre Duas Vari√°veis</a></li>
            <li><a href="#cap32">Cap√≠tulo 32 - Organizar uma Array</a></li>
            <li><a href="#cap33">Cap√≠tulo 33 - STRUCT</a></li>
            <li><a href="#cap34">Cap√≠tulo 34 - TYPEDEF</a></li>
            <li><a href="#cap35">Cap√≠tulo 35 - Arrays de STRUCTS</a></li>
            <li><a href="#cap36">Cap√≠tulo 36 - ENUMS</a></li>
            <li><a href="#cap37">Cap√≠tulo 37 - N√∫meros Aleat√≥rios</a></li>
            <li><a href="#cap38">Cap√≠tulo 38 - Operadores Bitwise</a></li>
            <li><a href="#cap39">Cap√≠tulo 39 - Endere√ßos de Mem√≥ria</a></li>
            <li><a href="#cap40">Cap√≠tulo 40 - Ponteiros</a></li>
            <li><a href="#cap41">Cap√≠tulo 41 - Criando arquivos</a></li>
            <li><a href="#cap42">Cap√≠tulo 42 - Lendo arquivos</a></li>
            <li><a href="#cap43">Cap√≠tulo 43 - Conclus√£o <strong>(EM FASE DE FINALIZA√á√ÉO)</strong></a></li>
            <li><a href="#cap44">Cap√≠tulo 44 - Exerc√≠cios Pr√°ticos <strong>(EM FASE DE FINALIZA√á√ÉO)</strong></a></li>

        </ul>
    </div>

    <!-- Cap√≠tulo 1 -->
    <div id="cap1" class="chapter">
        <h2>Cap√≠tulo 1 - Instalando e Compilando C</h2>
        <p>Neste cap√≠tulo, voc√™ aprender√° a configurar seu ambiente para compilar programas em C usando duas IDEs populares: <strong>Code::Blocks</strong> e <strong>Visual Studio Code</strong>. Abordaremos os tr√™s principais sistemas operacionais.</p>
    
        <h3>üîπ Windows</h3>
        <h4>Op√ß√£o 1: Code::Blocks (recomendado para iniciantes)</h4>
        <ol>
            <li>Acesse: <a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="noopener">codeblocks.org/downloads</a></li>
            <li>Baixe o instalador: <strong>codeblocks-XX.XXmingw-setup.exe</strong></li>
            <li>Durante a instala√ß√£o, certifique-se de marcar a op√ß√£o para instalar o compilador MinGW.</li>
            <li>Abra o Code::Blocks e crie um novo projeto: <strong>File &gt; New &gt; Project &gt; Console Application</strong></li>
            <li>Siga os passos, selecione C como linguagem e compile usando <kbd>Build and Run</kbd> (atalho: <kbd>F9</kbd>)</li>
        </ol>
    
        <h4>Op√ß√£o 2: Visual Studio Code</h4>
        <ol>
            <li>Baixe e instale o <a rel="noopener" href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a></li>
            <li>Instale o <a rel="noopener" href="https://www.mingw-w64.org/" target="_blank">MinGW-w64</a>:
                <ul>
                    <li>Use o instalador <strong>MSYS2</strong> para facilitar.</li>
                    <li>Ou baixe diretamente o MinGW-w64 e adicione o caminho do bin√°rio ao <strong>PATH</strong> do sistema.</li>
                </ul>
            </li>
            <li>Abra o VS Code e instale as extens√µes:
                <ul>
                    <li><strong>C/C++</strong> (by Microsoft)</li>
                    <li><strong>Code Runner</strong> (opcional para testes r√°pidos)</li>
                </ul>
            </li>
            <li>Crie um arquivo <code>.c</code> e use <kbd>Ctrl + Alt + N</kbd> (Code Runner) ou configure um <strong>tasks.json</strong> para compilar com <code>gcc</code>.</li>
        </ol>
    
        <h3>üîπ MacOS</h3>
        <ol>
            <li>Abra o Terminal e digite:
                <pre><code>xcode-select --install</code></pre>
                Isso instalar√° o compilador <strong>clang</strong>.
            </li>
            <li>Voc√™ pode usar:
                <ul>
                    <li><strong>Code::Blocks</strong>: dispon√≠vel para Mac, mas menos usado.</li>
                    <li><strong>VS Code</strong>: Recomendado. Instale o VS Code e as mesmas extens√µes do Windows.</li>
                </ul>
            </li>
            <li>Compile seus arquivos .c com:
                <pre><code>clang programa.c -o programa
    ./programa</code></pre>
            </li>
        </ol>
    
        <h3>üîπ Linux (Ubuntu, Fedora, etc.)</h3>
        <ol>
            <li>No terminal, instale as ferramentas de desenvolvimento:
                <pre><code>sudo apt update
    sudo apt install build-essential</code></pre>
            </li>
            <li>Ou, em sistemas baseados em Fedora:
                <pre><code>sudo dnf groupinstall "Development Tools"</code></pre>
            </li>
            <li>Instale o VS Code:
                <ul>
                    <li>Dispon√≠vel via Snap ou pacotes .deb/.rpm.</li>
                    <li>Instale as extens√µes C/C++ normalmente.</li>
                </ul>
            </li>
            <li>Compile no terminal com:
                <pre><code>gcc programa.c -o programa
    ./programa</code></pre>
            </li>
        </ol>
    
        <h3>‚úÖ Testando um c√≥digo</h3>
        <p>Copie o seguinte c√≥digo e compile com qualquer m√©todo descrito acima:</p>
        <pre><code>#include &lt;stdio.h&gt;
    
    int main() {
        printf("Ol√°, mundo em C!\n");
        return 0;
    }</code></pre>
    
        <p>Se aparecer "Ol√°, mundo em C!" no terminal ou console, sua configura√ß√£o est√° funcionando!</p>
    </div>
    

    <!-- Cap√≠tulo 2 -->
    <div id="cap2" class="chapter">
        <h2>Cap√≠tulo 2 - Coment√°rios e Sequ√™ncias de Escape</h2>
        <p>Coment√°rios s√£o usados para deixar o c√≥digo mais simples de se entender.</p>
        <p>Em <strong>C</strong> duas barras "<strong>//</strong>" significa uma linha de coment√°rio.</p>
        <p>Para comentar em mais de uma linha usa-se "<strong>/**/</strong>"</p>
        <h3>Coment√°rios</h3>
        <pre><code>// Coment√°rio de uma linha
/* Coment√°rio de 
   m√∫ltiplas linhas */</code></pre>
        
        <h3>Sequ√™ncias de Escape</h3>
        <p>Combina√ß√£o de caracteres que consiste em usar contra-barra "<strong>\</strong>" seguido de uma letra ou combina√ß√£o de d√≠gitos.</p>
        <table>
            <tr>
                <th>Sequ√™ncia</th>
                <th>Descri√ß√£o</th>
            </tr>
            <tr>
                <td><strong>\n</strong></td>
                <td>Nova linha</td>
            </tr>
            <tr>
                <td><strong>\t</strong></td>
                <td>Tabula√ß√£o Horizontal</td>
            </tr>
            <tr>
                <td>"<strong>\"\"</strong>"</td>
                <td>Para mostrar aspas duplas ou simples sem comprometer a sintaxe</td>
            </tr>
            <tr>
                <td><strong>\b</strong></td>
                <td>Backspace</td>
            </tr>
            <tr>
                <td><strong>\v</strong></td>
                <td>Tubula√ß√£o Vertical</td>
            </tr>
        </table>
        </div>

    <!-- Cap√≠tulo 3 -->
<div id="cap3" class="chapter">
    <h2>Cap√≠tulo 3 - Vari√°veis</h2>
    <p>Vari√°veis s√£o utilizadas para armazenar valores na mem√≥ria do computador. Em C, todas as vari√°veis devem ser declaradas com um tipo.</p>

    <h3>Exemplo b√°sico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 25;
    float altura = 1.75;
    char letra = 'A';
    char nome[] = "Carlos";

    printf("Idade: %d\n", idade);
    printf("Altura: %.2f\n", altura);
    printf("Letra: %c\n", letra);
    printf("Nome: %s", nome);

    return 0;
}</code></pre>

    <h3>Tipos comuns de vari√°veis:</h3>
    <ul>
        <li><strong>int</strong> ‚Äì n√∫meros inteiros (ex: 1, 50, -30)</li>
        <li><strong>float</strong> ‚Äì n√∫meros reais com ponto flutuante (ex: 3.14, -0.99)</li>
        <li><strong>char</strong> ‚Äì caracteres √∫nicos (ex: 'A', 'b', '1')</li>
        <li><strong>char []</strong> - carcateres em cadeia (ex: "Ol√°", "Mundo", "C")</li>
    </ul>

    <h3>Regras para nomes de vari√°veis:</h3>
    <ul>
        <li>Devem come√ßar com uma letra ou underscore (_)</li>
        <li>N√£o podem conter espa√ßos ou caracteres especiais</li>
        <li>S√£o sens√≠veis a mai√∫sculas e min√∫sculas</li>
        <li>N√£o podem ser palavras reservadas da linguagem (ex: if, int, void, define etc)</li>
    </ul>

    <h3>Boa pr√°tica:</h3>
    <p>Use nomes descritivos e significativos. Exemplo: <code>int idadeUsuario;</code> em vez de <code>int x;</code></p>
</div>

<!-- Cap√≠tulo 4 -->
<div id="cap4" class="chapter">
    <h2>Cap√≠tulo 4 - Tipos de Dados</h2>
    <p>Os tipos de dados em C determinam o tamanho da mem√≥ria e o tipo de valor que uma vari√°vel pode armazenar.</p>

    <h3>Exemplos com declara√ß√£o, uso e tamanho:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    char a = 'C';                       // 1 byte: caractere √∫nico (%c)
    char b[] = "Bro";                  // array de caracteres (%s)

    float c = 3.141592;                // 4 bytes, 6-7 d√≠gitos (%f)
    double d = 3.141592653589793;      // 8 bytes, 15-16 d√≠gitos (%lf)

    bool e = true;                     // 1 byte, verdadeiro ou falso (%d)

    char f = 100;                      // 1 byte (-128 a 127) (%d ou %c)
    unsigned char g = 255;             // 1 byte (0 a 255) (%d ou %c)

    short int h = 32767;               // 2 bytes (-32.768 a 32.767) (%d)
    unsigned short i = 65535;          // 2 bytes (0 a 65.535) (%d)

    long int j = 2147483647;           // 4 bytes (-2.147.483.648 a 2.147.483.647) (%d)
    unsigned long int k = 4294967295L; // 4 bytes (0 a 4.294.967.295) (%u)

    long long int l = 9223372036854775807;         // 8 bytes (%lld)
    unsigned long long int m = 18446744073709551615U; // 8 bytes (%llu)

    printf("Exemplo: %c, %s, %.2f, %.15lf\n", a, b, c, d);

    return 0;
}</code></pre>

    <h3>Tabela com tipos, tamanhos e faixas:</h3>
    <table>
        <tr>
            <th>Tipo</th>
            <th>Tamanho</th>
            <th>Faixa</th>
            <th>Formato</th>
        </tr>
        <tr>
            <td>char</td>
            <td>1 byte</td>
            <td>-128 a +127</td>
            <td>%c ou %d</td>
        </tr>
        <tr>
            <td>unsigned char</td>
            <td>1 byte</td>
            <td>0 a 255</td>
            <td>%c ou %d</td>
        </tr>
        <tr>
            <td>short int</td>
            <td>2 bytes</td>
            <td>-32.768 a +32.767</td>
            <td>%d</td>
        </tr>
        <tr>
            <td>unsigned short</td>
            <td>2 bytes</td>
            <td>0 a 65.535</td>
            <td>%d</td>
        </tr>
        <tr>
            <td>int</td>
            <td>4 bytes</td>
            <td>-2.147.483.648 a +2.147.483.647</td>
            <td>%d</td>
        </tr>
        <tr>
            <td>unsigned int</td>
            <td>4 bytes</td>
            <td>0 a 4.294.967.295</td>
            <td>%u</td>
        </tr>
        <tr>
            <td>long int</td>
            <td>4 bytes</td>
            <td>Mesma faixa do int</td>
            <td>%ld</td>
        </tr>
        <tr>
            <td>unsigned long int</td>
            <td>4 bytes</td>
            <td>0 a 4.294.967.295</td>
            <td>%lu</td>
        </tr>
        <tr>
            <td>long long int</td>
            <td>8 bytes</td>
            <td>-9 quintilh√µes a +9 quintilh√µes</td>
            <td>%lld</td>
        </tr>
        <tr>
            <td>unsigned long long int</td>
            <td>8 bytes</td>
            <td>0 a 18 quintilh√µes</td>
            <td>%llu</td>
        </tr>
        <tr>
            <td>float</td>
            <td>4 bytes</td>
            <td>~6-7 d√≠gitos de precis√£o</td>
            <td>%f</td>
        </tr>
        <tr>
            <td>double</td>
            <td>8 bytes</td>
            <td>~15-16 d√≠gitos de precis√£o</td>
            <td>%lf</td>
        </tr>
        <tr>
            <td>bool</td>
            <td>1 byte</td>
            <td>true (1) ou false (0)</td>
            <td>%d</td>
        </tr>
    </table>

    <h3>Notas importantes:</h3>
    <ul>
        <li>Use <code>#include &lt;stdbool.h&gt;</code> para usar o tipo <code>bool</code></li>
        <li>O modificador <code>unsigned</code> elimina a possibilidade de n√∫meros negativos</li>
        <li>Tipos <code>long</code> e <code>short</code> s√£o modificadores de <code>int</code></li>
    </ul>
</div>

<!-- Cap√≠tulo 5 -->
<div id="cap5" class="chapter">
    <h2>Cap√≠tulo 5 - Especificadores de Formata√ß√£o</h2>
    <p>Especificadores de formata√ß√£o s√£o usados com <code>printf()</code> para exibir e <code>scanf()</code> para ler dados corretamente.</p>

    <h3>Principais especificadores para <code>printf()</code>:</h3>
    <table>
        <tr>
            <th>Especificador</th>
            <th>Descri√ß√£o</th>
            <th>Exemplo de uso</th>
        </tr>
        <tr>
            <td>%d</td>
            <td>N√∫mero inteiro decimal (int)</td>
            <td>printf("Valor: %d", idade);</td>
        </tr>
        <tr>
            <td>%u</td>
            <td>Inteiro sem sinal (unsigned int)</td>
            <td>printf("Valor: %u", idade);</td>
        </tr>
        <tr>
            <td>%f</td>
            <td>N√∫mero de ponto flutuante (float)</td>
            <td>printf("Altura: %.2f", altura);</td>
        </tr>
        <tr>
            <td>%lf</td>
            <td>N√∫mero de ponto flutuante (double)</td>
            <td>printf("PI: %.15lf", pi);</td>
        </tr>
        <tr>
            <td>%c</td>
            <td>Caractere √∫nico</td>
            <td>printf("Letra: %c", letra);</td>
        </tr>
        <tr>
            <td>%s</td>
            <td>String (texto)</td>
            <td>printf("Nome: %s", nome);</td>
        </tr>
        <tr>
            <td>%lld</td>
            <td>Long long int (inteiros grandes)</td>
            <td>printf("Valor: %lld", numeroGrande);</td>
        </tr>
        <tr>
            <td>%llu</td>
            <td>Unsigned long long int</td>
            <td>printf("Valor: %llu", numeroGrande);</td>
        </tr>
        <tr>
            <td>%%</td>
            <td>Imprime o caractere %</td>
            <td>printf("Taxa: 100%%");</td>
        </tr>
    </table>

    <h3>Formata√ß√£o com casas decimais:</h3>
    <p>Voc√™ pode controlar a quantidade de casas decimais exibidas com <code>%.nf</code>, onde <code>n</code> √© o n√∫mero de casas.</p>
    <pre><code>float preco = 9.99;
printf("Pre√ßo: %.2f\n", preco); // Sa√≠da: Pre√ßo: 9.99</code></pre>

    <h3>Exemplo completo:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 25;
    float altura = 1.75;
    char letra = 'M';
    char nome[] = "Miguel";

    printf("Nome: %s\n", nome);
    printf("Idade: %d anos\n", idade);
    printf("Altura: %.2f metros\n", altura);
    printf("Inicial: %c\n", letra);

    return 0;
}</code></pre>

    <h3>Dica b√¥nus:</h3>
    <p>Voc√™ pode alinhar valores com largura m√≠nima usando, por exemplo, <code>%10d</code> (alinha √† direita em 10 espa√ßos).</p>
</div>

<!-- Cap√≠tulo 6 -->
<div id="cap6" class="chapter">
    <h2>Cap√≠tulo 6 - Constantes</h2>

    <p>Constantes s√£o valores fixos que n√£o podem ser alterados durante a execu√ß√£o do programa. Elas s√£o muito √∫teis para tornar o c√≥digo mais leg√≠vel e seguro.
        Se tentar alterar o valor durante a execu√ß√£o, o programa mostrar√° um erro.
    </p>

    <h3>Usando <code>#define</code></h3>
    <p>A diretiva <code>#define</code> permite criar constantes simb√≥licas:</p>

<pre><code>#include &lt;stdio.h&gt;

#define PI 3.14159

int main() {
    printf("O valor de PI √©: %f\n", PI);
    return 0;
}</code></pre>

    <p><strong>Observa√ß√£o:</strong> O <code>#define</code> n√£o usa ponto e v√≠rgula no final da linha.</p>

    <h3>Usando <code>const</code></h3>
    <p>Tamb√©m podemos declarar constantes com a palavra-chave <code>const</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    const int idade = 18;
    printf("Idade m√≠nima: %d\n", idade);
    return 0;
}</code></pre>

    <strong><p>Ao tentar alterar o valor de uma vari√°vel <code>const</code>, o compilador gerar√° um erro.</p></strong>

    <h3>Diferen√ßas entre <code>#define</code> e <code>const</code></h3>
    <table>
        <tr>
            <th>Aspecto</th>
            <th>#define</th>
            <th>const</th>
        </tr>
        <tr>
            <td>Tipo de dado</td>
            <td>N√£o possui tipo</td>
            <td>Possui tipo</td>
        </tr>
        <tr>
            <td>Visibilidade</td>
            <td>Substitui√ß√£o textual</td>
            <td>Checagem de tipo pelo compilador</td>
        </tr>
        <tr>
            <td>Depura√ß√£o</td>
            <td>Mais dif√≠cil</td>
            <td>Mais f√°cil</td>
        </tr>
    </table>

    <h3>Boas pr√°ticas</h3>
    <ul>
        <li>Use <code>#define</code> para valores que n√£o mudam e s√£o usados amplamente no c√≥digo.</li>
        <li>Use <code>const</code> quando quiser proteger o valor de uma vari√°vel dentro de um escopo.</li>
        <li>Use letras mai√∫sculas para nomes de constantes simb√≥licas com <code>#define</code>.</li>
    </ul>

    <p>Constantes ajudam a evitar erros e deixam o c√≥digo mais claro e f√°cil de manter.</p>
</div>



<!-- Cap√≠tulo 7 -->
<div id="cap7" class="chapter">
    <h2>Cap√≠tulo 7 - Operadores Aritm√©ticos</h2>
    <p>Operadores aritm√©ticos s√£o usados para realizar opera√ß√µes matem√°ticas com vari√°veis ou valores diretamente.</p>

    <h3>Principais operadores:</h3>
    <table>
        <tr>
            <th>Operador</th>
            <th>Opera√ß√£o</th>
            <th>Exemplo</th>
        </tr>
        <tr>
            <td><strong>+</strong></td>
            <td>Adi√ß√£o</td>
            <td>int soma = a + b;</td>
        </tr>
        <tr>
            <td><strong>-</strong></td>
            <td>Subtra√ß√£o</td>
            <td>int sub = a - b;</td>
        </tr>
        <tr>
            <td><strong>*</strong></td>
            <td>Multiplica√ß√£o</td>
            <td>int mult = a * b;</td>
        </tr>
        <tr>
            <td><strong>/</strong></td>
            <td>Divis√£o</td>
            <td>int div = a / b;</td>
        </tr>
        <tr>
            <td><strong>%</strong></td>
            <td>M√≥dulo (resto da divis√£o)</td>
            <td>int resto = a % b;</td>
        </tr>
        <tr>
            <td><strong>++</strong></td>
            <td>Incremento (por 1)</td>
            <td>nome_variavel++</td>
        </tr>
        <tr>
            <td><strong>--</strong></td>
            <td>Decremento (por 1)</td>
            <td>nome_vari√°vel--</td>
        </tr>
    </table>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = 3;

    printf("Adi√ß√£o: %d\n", a + b);
    printf("Subtra√ß√£o: %d\n", a - b);
    printf("Multiplica√ß√£o: %d\n", a * b);
    printf("Divis√£o: %d\n", a / b);
    printf("Resto da divis√£o: %d\n", a % b);

    a++;
    b--;

    printf("Incremento: %d", a);
    printf("Decremento: %d", b);
    return 0;
}</code></pre>

    <h3>Cuidados com a divis√£o:</h3>
    <p>Quando voc√™ divide dois inteiros, o resultado ser√° um inteiro. Para obter um n√∫mero decimal, use <code>float</code> ou <code>double</code>.</p>

    <h4>Exemplo com ponto flutuante:</h4>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    float x = 7.0;
    float y = 2.0;

    printf("Divis√£o com float: %.2f\n", x / y); // Sa√≠da: 3.50
    return 0;
}</code></pre>

    <h3>Pot√™ncia em C:</h3>
    <p>Para fazer c√°lculo de pot√™ncia, use a fun√ß√£o <code>pow()</code> da biblioteca <code>math.h</code>.</p>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int base = 2;
    int expoente = 3;
    int resultado = pow(base, expoente);

    printf("%d elevado a %d = %d\n", base, expoente, resultado);
    return 0;
}</code></pre>

    <p>Lembre-se de compilar com <code>-lm</code> para incluir a biblioteca matem√°tica:</p>
    <pre><code>gcc arquivo.c -o programa -lm</code></pre>
</div>

<!-- Cap√≠tulo 8 -->
<div id="cap8" class="chapter">
    <h2>Cap√≠tulo 8 - Operadores de Atribui√ß√£o Compostos</h2>
    <p>Esses operadores permitem realizar uma opera√ß√£o matem√°tica e atribui√ß√£o ao mesmo tempo. Eles tornam o c√≥digo mais enxuto e f√°cil de entender.</p>

    <h3>Principais operadores compostos:</h3>
    <table>
        <tr>
            <th>Operador</th>
            <th>Significado</th>
            <th>Equivalente</th>
        </tr>
        <tr>
            <td>+=</td>
            <td>Adiciona e atribui</td>
            <td>x += 5 ‚Üí x = x + 5</td>
        </tr>
        <tr>
            <td>-=</td>
            <td>Subtrai e atribui</td>
            <td>x -= 3 ‚Üí x = x - 3</td>
        </tr>
        <tr>
            <td>*=</td>
            <td>Multiplica e atribui</td>
            <td>x *= 2 ‚Üí x = x * 2</td>
        </tr>
        <tr>
            <td>/=</td>
            <td>Divide e atribui</td>
            <td>x /= 4 ‚Üí x = x / 4</td>
        </tr>
        <tr>
            <td>%=</td>
            <td>M√≥dulo e atribui</td>
            <td>x %= 3 ‚Üí x = x % 3</td>
        </tr>
    </table>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int x = 10;

    x += 5;
    printf("x += 5 -> %d\n", x);

    x -= 3;
    printf("x -= 3 -> %d\n", x);

    x *= 2;
    printf("x *= 2 -> %d\n", x);

    x /= 4;
    printf("x /= 4 -> %d\n", x);

    x %= 3;
    printf("x %%= 3 -> %d\n", x);

    return 0;
}</code></pre>

    <p>Esses operadores s√£o √∫teis especialmente quando estamos atualizando vari√°veis dentro de la√ßos e fun√ß√µes matem√°ticas repetidas.</p>

    <h3>Observa√ß√£o</h3>
    <p>Os operadores de incremento e decremento vistos no cap√≠tulo anterior tamb√©m possuem liga√ß√£o com os operadores compostos.</p>
    <ul>
    <li><p><strong>x++</strong> √© o mesmo que <strong>x += 1</strong>.</p></li>
    <li><p><strong>x--</strong> √© o mesmo que <strong>x -= 1</strong>.</p></li>
</ul>
    <p>Se for para acrescentar o diminuir o valor por um, pode-se usar tanto uma forma quanto a outra.</p>
</div>

<!-- Cap√≠tulo 9 -->
<div id="cap9" class="chapter">
    <h2>Cap√≠tulo 9 - Entrada de Dados do Usu√°rio</h2>
    <p>Em C, utilizamos a fun√ß√£o <code>scanf()</code> para capturar informa√ß√µes digitadas pelo usu√°rio durante a execu√ß√£o do programa.</p>

    <h3>Exemplo com n√∫mero inteiro:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade;
    printf("Digite sua idade: ");
    scanf("%d", &idade);
    printf("Voc√™ tem %d anos.\n", idade);
    return 0;
}</code></pre>

    <h3>Exemplo com n√∫mero decimal:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    float altura;
    printf("Digite sua altura em metros: ");
    scanf("%f", &altura);
    printf("Altura registrada: %.2f metros\n", altura);
    return 0;
}</code></pre>

    <h3>Exemplo com caractere:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    char inicial;
    printf("Digite a primeira letra do seu nome: ");
    scanf(" %c", &inicial); // Espa√ßo antes de %c para ignorar o \n do buffer
    printf("Letra registrada: %c\n", inicial);
    return 0;
}</code></pre>

    <h3>Importante:</h3>
    <ul>
        <li>Sempre use o s√≠mbolo <code>&amp;</code> (e comercial) antes da vari√°vel no <code>scanf</code> para passar o endere√ßo de mem√≥ria.</li>
        <li>Para strings, n√£o se usa <code>&amp;</code>.</li>
    </ul>

    <h3>Exemplo com string:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    char nome[50];
    printf("Digite seu nome: ");
    scanf("%s", nome); // l√™ at√© o primeiro espa√ßo
    printf("Ol√°, %s!\n", nome);
    return 0;
}</code></pre>

    <p>Para ler nomes completos com espa√ßos, voc√™ pode usar <code>fgets()</code> no lugar de <code>scanf()</code>:</p>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    char nome[50];
    printf("Digite seu nome completo: ");
    fgets(nome, sizeof(nome), stdin);
    printf("Seja bem-vindo, %s", nome);
    return 0;
}</code></pre>
</div>

<!-- Cap√≠tulo 10 -->
<div id="cap10" class="chapter">
    <h2>Cap√≠tulo 10 - Fun√ß√µes Matem√°ticas</h2>
    <p>A linguagem C oferece diversas fun√ß√µes matem√°ticas que facilitam c√°lculos mais avan√ßados. Essas fun√ß√µes est√£o dispon√≠veis na biblioteca <code>&lt;math.h&gt;</code>.</p>

    <h3>Importante:</h3>
    <p>Para usar as fun√ß√µes matem√°ticas, lembre-se de incluir <code>#include &lt;math.h&gt;</code> e compilar com a flag <code>-lm</code> (no Linux/Mac):</p>
    <pre><code>gcc programa.c -o programa -lm</code></pre>

    <h3>Principais fun√ß√µes:</h3>
    <ul>
        <li><code>sqrt(x)</code> ‚Äì raiz quadrada de <code>x</code></li>
        <li><code>pow(base, expoente)</code> ‚Äì pot√™ncia</li>
        <li><code>ceil(x)</code> ‚Äì arredonda para cima</li>
        <li><code>floor(x)</code> ‚Äì arredonda para baixo</li>
        <li><code>round(x)</code> ‚Äì arredonda para o inteiro mais pr√≥ximo</li>
        <li><code>fabs(x)</code> ‚Äì valor absoluto (para float/double)</li>
    </ul>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    double raiz = sqrt(16);
    double potencia = pow(2, 5);
    double cima = ceil(3.2);
    double baixo = floor(3.8);
    double arredondado = round(4.6);
    double absoluto = fabs(-9.7);

    printf("Raiz quadrada de 16: %.2f\n", raiz);
    printf("2 elevado a 5: %.2f\n", potencia);
    printf("Arredondado para cima (3.2): %.2f\n", cima);
    printf("Arredondado para baixo (3.8): %.2f\n", baixo);
    printf("Arredondado (4.6): %.2f\n", arredondado);
    printf("Valor absoluto de -9.7: %.2f\n", absoluto);

    return 0;
}</code></pre>

    <h3>Dica:</h3>
    <p>Essas fun√ß√µes s√£o especialmente √∫teis em programas que envolvem c√°lculos cient√≠ficos, financeiros ou gr√°ficos.</p>
</div>

<!-- Cap√≠tulo 11 -->
<div id="cap11" class="chapter">
    <h2>Cap√≠tulo 11 - Condi√ß√µes IF, ELSE IF e ELSE</h2>
    <p>As estruturas condicionais permitem ao programa tomar decis√µes com base em determinadas condi√ß√µes.</p>

    <h3>Sintaxe b√°sica:</h3>
    <pre><code>if (condi√ß√£o) {
    // c√≥digo se a condi√ß√£o for verdadeira
} else if (outra condi√ß√£o) {
    // c√≥digo se a outra condi√ß√£o for verdadeira
} else {
    // c√≥digo se nenhuma das condi√ß√µes anteriores for verdadeira
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade;

    printf("Digite sua idade: ");
    scanf("%d", &idade);

    if (idade &lt; 12) {
        printf("Voc√™ √© uma crian√ßa.\n");
    } else if (idade &lt; 18) {
        printf("Voc√™ √© um adolescente.\n");
    } else if (idade &lt; 60) {
        printf("Voc√™ √© um adulto.\n");
    } else {
        printf("Voc√™ √© um idoso.\n");
    }

    return 0;
}</code></pre>

    <h3>Explica√ß√£o:</h3>
    <ul>
        <li><strong>if</strong>: verifica a primeira condi√ß√£o.</li>
        <li><strong>else if</strong>: verifica outra condi√ß√£o se a anterior for falsa.</li>
        <li><strong>else</strong>: executa um bloco de c√≥digo se nenhuma condi√ß√£o for satisfeita.</li>
    </ul>

    <h3>Dica:</h3>
    <p>Use par√™nteses <code>()</code> ao redor das condi√ß√µes e chaves <code>{}</code> mesmo para blocos com uma linha ‚Äì isso ajuda a evitar erros.</p>
</div>

<!-- Cap√≠tulo 12 -->
<div id="cap12" class="chapter">
    <h2>Cap√≠tulo 12 - Condi√ß√µes SWITCH, CASE e DEFAULT</h2>
    <p>A estrutura <code>switch</code> √© usada para comparar uma vari√°vel com v√°rios valores poss√≠veis (casos).</p>

    <h3>Sintaxe:</h3>
    <pre><code>switch (express√£o) {
    case valor1:
        // c√≥digo se express√£o == valor1
        break;
    case valor2:
        // c√≥digo se express√£o == valor2
        break;
    default:
        // c√≥digo se nenhum dos casos anteriores for verdadeiro
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int opcao;

    printf("Escolha uma op√ß√£o (1-3): ");
    scanf("%d", &opcao);

    switch (opcao) {
        case 1:
            printf("Voc√™ escolheu a op√ß√£o 1.\n");
            break;
        case 2:
            printf("Voc√™ escolheu a op√ß√£o 2.\n");
            break;
        case 3:
            printf("Voc√™ escolheu a op√ß√£o 3.\n");
            break;
        default:
            printf("Op√ß√£o inv√°lida.\n");
    }

    return 0;
}</code></pre>

    <h3>Detalhes importantes:</h3>
    <ul>
        <li><strong>break</strong> impede que os outros casos sejam executados.</li>
        <li><strong>default</strong> √© opcional, mas √∫til para tratar valores inesperados.</li>
        <li>A express√£o dentro de <code>switch</code> geralmente √© do tipo <code>int</code> ou <code>char</code>.</li>
    </ul>

    <h3>Boa pr√°tica:</h3>
    <p>Sempre use <code>break</code> ao final de cada <code>case</code>, a menos que voc√™ queira executar mais de um bloco em sequ√™ncia (fall-through).</p>
</div>

<!-- Cap√≠tulo 13 -->
<div id="cap13" class="chapter">
    <h2>Cap√≠tulo 13 - Operador L√≥gico AND (&&)</h2>
    <p>O operador l√≥gico <code>&&</code> (AND) √© usado para verificar se duas condi√ß√µes s√£o verdadeiras ao mesmo tempo.</p>

    <h3>Sintaxe:</h3>
    <pre><code>if (condi√ß√£o1 && condi√ß√£o2) {
    // Executa este bloco se ambas as condi√ß√µes forem verdadeiras
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 20;
    int temCarteira = 1;

    if (idade >= 18 && temCarteira) {
        printf("Pode dirigir.\n");
    } else {
        printf("N√£o pode dirigir.\n");
    }

    return 0;
}</code></pre>

    <h3>Explica√ß√£o:</h3>
    <ul>
        <li><code>idade >= 18</code> verifica se a pessoa √© maior de idade.</li>
        <li><code>temCarteira</code> (valor diferente de zero) representa que a pessoa tem carteira de motorista.</li>
        <li>Ambas as condi√ß√µes devem ser verdadeiras para que a pessoa possa dirigir.</li>
    </ul>

    <h3>Tabela verdade do operador AND:</h3>
    <table>
        <tr>
            <th>Condi√ß√£o 1</th>
            <th>Condi√ß√£o 2</th>
            <th>Resultado</th>
        </tr>
        <tr>
            <td>Verdadeiro</td>
            <td>Verdadeiro</td>
            <td>Verdadeiro</td>
        </tr>
        <tr>
            <td>Verdadeiro</td>
            <td>Falso</td>
            <td>Falso</td>
        </tr>
        <tr>
            <td>Falso</td>
            <td>Verdadeiro</td>
            <td>Falso</td>
        </tr>
        <tr>
            <td>Falso</td>
            <td>Falso</td>
            <td>Falso</td>
        </tr>
    </table>
</div>

<!-- Cap√≠tulo 14 -->
<div id="cap14" class="chapter">
    <h2>Cap√≠tulo 14 - Operador L√≥gico OR (||)</h2>
    <p>O operador l√≥gico <code>||</code> (OR) √© usado para verificar se pelo menos uma de duas condi√ß√µes √© verdadeira.</p>

    <h3>Sintaxe:</h3>
    <pre><code>if (condi√ß√£o1 || condi√ß√£o2) {
    // Executa este bloco se pelo menos uma condi√ß√£o for verdadeira
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 70;
    int estudante = 0;

    if (idade &lt;= 18 || idade &gt;= 65) {
        printf("Tem direito a meia-entrada.\n");
    } else {
        printf("Precisa pagar inteira.\n");
    }

    return 0;
}</code></pre>

    <h3>Explica√ß√£o:</h3>
    <ul>
        <li><code>idade &lt;= 18</code> verifica se √© menor de idade.</li>
        <li><code>idade &gt;= 65</code> verifica se √© idoso.</li>
        <li>Se qualquer uma dessas condi√ß√µes for verdadeira, a pessoa tem direito a meia-entrada.</li>
    </ul>

    <h3>Tabela verdade do operador OR:</h3>
    <table>
        <tr>
            <th>Condi√ß√£o 1</th>
            <th>Condi√ß√£o 2</th>
            <th>Resultado</th>
        </tr>
        <tr>
            <td>Verdadeiro</td>
            <td>Verdadeiro</td>
            <td>Verdadeiro</td>
        </tr>
        <tr>
            <td>Verdadeiro</td>
            <td>Falso</td>
            <td>Verdadeiro</td>
        </tr>
        <tr>
            <td>Falso</td>
            <td>Verdadeiro</td>
            <td>Verdadeiro</td>
        </tr>
        <tr>
            <td>Falso</td>
            <td>Falso</td>
            <td>Falso</td>
        </tr>
    </table>
</div>

<!-- Cap√≠tulo 15 -->
<div id="cap15" class="chapter">
    <h2>Cap√≠tulo 15 - Operador L√≥gico NOT (!)</h2>
    <p>O operador l√≥gico <code>!</code> (NOT) inverte o valor de uma express√£o booleana. Se a condi√ß√£o for verdadeira, ela se torna falsa, e vice-versa.</p>

    <h3>Sintaxe:</h3>
    <pre><code>if (!condi√ß√£o) {
    // Executa este bloco se a condi√ß√£o for FALSA
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int temCarteira = 0;

    if (!temCarteira) {
        printf("Voc√™ n√£o pode dirigir.\n");
    } else {
        printf("Voc√™ pode dirigir.\n");
    }

    return 0;
}</code></pre>

    <h3>Explica√ß√£o:</h3>
    <ul>
        <li>A vari√°vel <code>temCarteira</code> est√° com valor 0 (falso).</li>
        <li><code>!temCarteira</code> inverte para verdadeiro.</li>
        <li>Logo, o programa imprime: "Voc√™ n√£o pode dirigir."</li>
    </ul>

    <h3>Tabela verdade do operador NOT:</h3>
    <table>
        <tr>
            <th>Valor Original</th>
            <th>Resultado com NOT (!)</th>
        </tr>
        <tr>
            <td>Verdadeiro (1)</td>
            <td>Falso (0)</td>
        </tr>
        <tr>
            <td>Falso (0)</td>
            <td>Verdadeiro (1)</td>
        </tr>
    </table>
</div>

<!-- Cap√≠tulo 16 -->
<div id="cap16" class="chapter">
    <h2>Cap√≠tulo 16 - Fun√ß√µes</h2>
    <p>Fun√ß√µes s√£o blocos de c√≥digo reutiliz√°veis que executam tarefas espec√≠ficas. Elas ajudam a organizar o programa, melhorar a legibilidade e evitar repeti√ß√£o de c√≥digo.</p>

    <h3>Sintaxe b√°sica:</h3>
    <pre><code>tipo_retorno nomeDaFuncao(par√¢metros) {
    // corpo da fun√ß√£o
}</code></pre>

    <h3>Exemplo simples:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Fun√ß√£o que imprime uma sauda√ß√£o
void saudacao() {
    printf("Ol√°, bem-vindo ao curso de C!\n");
}

int main() {
    saudacao(); // chamada da fun√ß√£o
    return 0;
}</code></pre>

    <h3>Fun√ß√£o com retorno de valor:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Fun√ß√£o que retorna a soma de dois n√∫meros
int soma(int a, int b) {
    return a + b;
}

int main() {
    int resultado = soma(3, 4);
    printf("Resultado: %d\n", resultado);
    return 0;
}</code></pre>

    <h3>Vantagens de usar fun√ß√µes:</h3>
    <ul>
        <li>Modulariza√ß√£o do c√≥digo</li>
        <li>Reutiliza√ß√£o de l√≥gica</li>
        <li>Facilidade na manuten√ß√£o</li>
        <li>Melhora a legibilidade</li>
    </ul>

    <h3>Dica:</h3>
    <p>Em programas grandes, agrupe fun√ß√µes semelhantes em arquivos separados para organizar melhor o projeto.</p>
</div>

<!-- Cap√≠tulo 17 -->
<div id="cap17" class="chapter">
    <h2>Cap√≠tulo 17 - Argumentos</h2>
    <p>Argumentos s√£o os valores passados para uma fun√ß√£o no momento de sua chamada. Eles permitem que uma fun√ß√£o trabalhe com dados fornecidos externamente.</p>

    <h3>Definindo e usando argumentos:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Fun√ß√£o com dois argumentos
void mostrarSoma(int x, int y) {
    printf("Soma: %d\n", x + y);
}

int main() {
    mostrarSoma(10, 5); // argumentos 10 e 5
    return 0;
}</code></pre>

    <h3>Par√¢metros vs Argumentos:</h3>
    <ul>
        <li><strong>Par√¢metros:</strong> vari√°veis na declara√ß√£o da fun√ß√£o (ex: <code>int x, int y</code>)</li>
        <li><strong>Argumentos:</strong> valores reais passados na chamada da fun√ß√£o (ex: <code>10, 5</code>)</li>
    </ul>

    <h3>Fun√ß√£o com mais de dois argumentos:</h3>
    <pre><code>void mostrarDados(char nome[], int idade, float altura) {
    printf("Nome: %s\n", nome);
    printf("Idade: %d\n", idade);
    printf("Altura: %.2f\n", altura);
}

int main() {
    mostrarDados("Ana", 25, 1.68);
    return 0;
}</code></pre>

    <h3>Dica:</h3>
    <p>Use argumentos para tornar suas fun√ß√µes mais flex√≠veis e reutiliz√°veis. Evite usar vari√°veis globais sempre que poss√≠vel.</p>
</div>

<!-- Cap√≠tulo 18 -->
<div id="cap18" class="chapter">
    <h2>Cap√≠tulo 18 - Condi√ß√£o RETURN</h2>
    <p>A palavra-chave <code>return</code> √© usada em fun√ß√µes para devolver um valor ao local de onde a fun√ß√£o foi chamada.</p>

    <h3>Fun√ß√£o com retorno:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int somar(int a, int b) {
    return a + b;  // Retorna a soma
}

int main() {
    int resultado = somar(7, 3);
    printf("Resultado da soma: %d\n", resultado);
    return 0;
}</code></pre>

    <h3>Import√¢ncia do return:</h3>
    <ul>
        <li>Interrompe a execu√ß√£o da fun√ß√£o.</li>
        <li>Envia um valor de volta ao chamador da fun√ß√£o.</li>
        <li>√â obrigat√≥rio se a fun√ß√£o for declarada com tipo diferente de <code>void</code>.</li>
    </ul>

    <h3>Fun√ß√µes sem retorno:</h3>
    <p>Se a fun√ß√£o n√£o precisa retornar nenhum valor, ela deve ser declarada com o tipo <code>void</code>:</p>
    <pre><code>void mensagem() {
    printf("Fun√ß√£o sem retorno\n");
}</code></pre>

    <h3>Fun√ß√£o com retorno condicional:</h3>
    <pre><code>int maior(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}</code></pre>

    <h3>Dica:</h3>
    <p>
        Utilize <code>return</code> para tornar fun√ß√µes reutiliz√°veis e √∫teis em diversos contextos do seu programa.
    </p>
    <p>
        E tome cuidado com as <strong>Fun√ß√µes Recursivas</strong> (fun√ß√µes que chamam a s√≠ mesma), pois vai acarretar em um uma repeti√ß√£o infinita do c√≥digo.
    </p>
    <pre><code>void mensagem() {
    printf("Fun√ß√£o sem retorno\n");
    return mensagem; // Isso far√° com que o c√≥digo seja repetido v√°rias vezes sem parar
}</code></pre>
</div>

<!-- Cap√≠tulo 19 -->
<div id="cap19" class="chapter">
    <h2>Cap√≠tulo 19 - Operadores Tern√°rios</h2>
    <p>O operador tern√°rio √© uma forma curta de escrever uma estrutura condicional <code>if-else</code>.</p>

    <h3>Sintaxe:</h3>
    <pre><code>condi√ß√£o ? valor_se_verdadeiro : valor_se_falso;</code></pre>

    <h3>Exemplo b√°sico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 18;
    const char* status = (idade >= 18) ? "Maior de idade" : "Menor de idade";
    printf("%s\n", status);
    return 0;
}</code></pre>

    <h3>Como funciona:</h3>
    <ul>
        <li>A express√£o <code>idade >= 18</code> √© avaliada.</li>
        <li>Se for verdadeira, <code>"Maior de idade"</code> ser√° atribu√≠do a <code>status</code>.</li>
        <li>Se for falsa, <code>"Menor de idade"</code> ser√° atribu√≠do.</li>
    </ul>

    <h3>Compara√ß√£o com if-else:</h3>
    <pre><code>// Forma tradicional
if (idade >= 18)
    status = "Maior de idade";
else
    status = "Menor de idade";

// Forma com operador tern√°rio
status = (idade >= 18) ? "Maior de idade" : "Menor de idade";</code></pre>

    <h3>Dica:</h3>
    <p>O operador tern√°rio √© excelente para condi√ß√µes simples e express√µes curtas. Evite us√°-lo com l√≥gica complexa para manter a legibilidade do c√≥digo.</p>
</div>

<!-- Cap√≠tulo 20 -->
<div id="cap20" class="chapter">
    <h2>Cap√≠tulo 20 - Fun√ß√µes Prot√≥tipo</h2>
    <p>Fun√ß√µes prot√≥tipo s√£o declara√ß√µes feitas antes da fun√ß√£o principal <code>main()</code> para informar ao compilador que uma fun√ß√£o ser√° usada posteriormente.</p>

    <h3>Por que usar prot√≥tipos?</h3>
    <ul>
        <li>Evita erros de compila√ß√£o ao chamar fun√ß√µes antes de defini-las.</li>
        <li>Permite organizar o c√≥digo separando a l√≥gica em v√°rias partes.</li>
    </ul>

    <h3>Exemplo de fun√ß√£o com prot√≥tipo:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Prot√≥tipo da fun√ß√£o
void saudacao();

int main() {
    saudacao();  // Chamada da fun√ß√£o
    return 0;
}

// Defini√ß√£o da fun√ß√£o
void saudacao() {
    printf("Ol√°, bem-vindo ao mundo C!\n");
}</code></pre>

    <h3>Quando √© necess√°rio?</h3>
    <p>Se voc√™ declarar uma fun√ß√£o ap√≥s o <code>main()</code>, √© necess√°rio fornecer um prot√≥tipo antes dele. Isso informa ao compilador sobre a exist√™ncia da fun√ß√£o e seus par√¢metros.</p>

    <h3>Com par√¢metros:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Prot√≥tipo
int soma(int a, int b);

int main() {
    int resultado = soma(5, 3);
    printf("Resultado da soma: %d\n", resultado);
    return 0;
}

// Defini√ß√£o
int soma(int a, int b) {
    return a + b;
}</code></pre>

    <p>O prot√≥tipo <code>int soma(int a, int b);</code> informa ao compilador que essa fun√ß√£o receber√° dois inteiros e retornar√° um inteiro.</p>

    <h3>Dica:</h3>
    <p>Usar prot√≥tipos √© essencial em programas maiores e organizados em m√∫ltiplos arquivos. Eles garantem que o compilador conhe√ßa todas as fun√ß√µes usadas no programa.</p>
</div>

<!-- Cap√≠tulo 21 -->
<div id="cap21" class="chapter">
    <h2>Cap√≠tulo 21 - Fun√ß√µes String</h2>
    <p>A linguagem C n√£o possui um tipo de dado espec√≠fico para strings como outras linguagens modernas. Em vez disso, utiliza arrays de caracteres terminados com o caractere nulo <code>'\0'</code>.</p>

    <p>A biblioteca <code>&lt;string.h&gt;</code> fornece fun√ß√µes √∫teis para manipula√ß√£o de strings.</p>

    <h3>Principais fun√ß√µes:</h3>
    <ul>
        <li><code>strlen()</code> ‚Äì Retorna o comprimento da string (sem contar o '\0')</li>
        <li><code>strcpy()</code> ‚Äì Copia uma string para outra</li>
        <li><code>strcat()</code> ‚Äì Concatena (junta) duas strings</li>
        <li><code>strcmp()</code> ‚Äì Compara duas strings</li>
    </ul>

    <h3>Exemplo de uso:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char nome1[20] = "Ol√°";
    char nome2[] = " Mundo";

    strcat(nome1, nome2);  // Junta nome2 ao final de nome1

    printf("Resultado: %s\n", nome1);
    printf("Comprimento: %lu\n", strlen(nome1));

    return 0;
}</code></pre>

    <h3>Explica√ß√£o:</h3>
    <ul>
        <li><code>strcat()</code> juntou " Mundo" ao final de "Ol√°".</li>
        <li><code>strlen()</code> contou o n√∫mero de caracteres em "Ol√° Mundo".</li>
    </ul>

    <h3>Copiando strings:</h3>
    <pre><code>char destino[50];
char origem[] = "Texto de origem";

strcpy(destino, origem);
printf("Destino: %s\n", destino);</code></pre>

    <h3>Comparando strings:</h3>
    <pre><code>char a[] = "abc";
char b[] = "abc";

if (strcmp(a, b) == 0) {
    printf("As strings s√£o iguais.\n");
} else {
    printf("As strings s√£o diferentes.\n");
}</code></pre>

    <p><strong>Importante:</strong> as fun√ß√µes de string n√£o verificam automaticamente o tamanho dos arrays. Sempre assegure que h√° espa√ßo suficiente para evitar erros de mem√≥ria.</p>
</div>

<!-- Cap√≠tulo 22 -->
<div id="cap22" class="chapter">
    <h2>Cap√≠tulo 22 - Estrutura de Repeti√ß√£o FOR</h2>

    <p>A estrutura <code>for</code> √© usada para repetir um bloco de c√≥digo um n√∫mero definido de vezes. Ela √© ideal quando voc√™ sabe quantas vezes deseja que o loop seja executado.</p>

    <h3>Sintaxe:</h3>
    <pre><code>for (inicializa√ß√£o; condi√ß√£o; incremento) {
    // c√≥digo a ser executado
}</code></pre>

    <h3>Exemplo b√°sico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 0; i &lt; 5; i++) {
        printf("Valor de i: %d\n", i);
    }
    return 0;
}</code></pre>

    <p>Esse loop imprimir√° os valores de 0 a 4.</p>

    <h3>Explica√ß√£o dos par√¢metros:</h3>
    <ul>
        <li><strong>Inicializa√ß√£o:</strong> Executada uma vez no in√≠cio (ex: <code>int i = 0</code>)</li>
        <li><strong>Condi√ß√£o:</strong> Avaliada antes de cada itera√ß√£o (enquanto for <code>true</code>, o loop continua)</li>
        <li><strong>Incremento:</strong> Executado ao final de cada itera√ß√£o (ex: <code>i++</code>)</li>
    </ul>

    <h3>Exemplo com decremento:</h3>
    <pre><code>for (int j = 5; j &gt; 0; j--) {
    printf("Contagem regressiva: %d\n", j);
}</code></pre>

    <h3>Loop para somar n√∫meros:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int soma = 0;

    for (int i = 1; i &lt;= 10; i++) {
        soma += i;
    }

    printf("Soma de 1 a 10: %d\n", soma);
    return 0;
}</code></pre>

    <p><strong>Dica:</strong> loops <code>for</code> tamb√©m funcionam bem para percorrer arrays e estruturas repetitivas fixas.</p>
</div>


<!-- Cap√≠tulo 23 -->
<div id="cap23" class="chapter">
    <h2>Cap√≠tulo 23 - Estrutura de Repeti√ß√£o WHILE</h2>

    <p>A estrutura <code>while</code> √© utilizada para executar um bloco de c√≥digo repetidamente enquanto uma determinada condi√ß√£o for verdadeira.</p>

    <h3>Sintaxe do while:</h3>
    <pre><code>while (condi√ß√£o) {
    // bloco de c√≥digo a ser executado
}</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int i = 0;

    while (i &lt; 5) {
        printf("Valor de i: %d\n", i);
        i++;
    }

    return 0;
}</code></pre>

    <p>No exemplo acima, o loop <code>while</code> continuar√° executando enquanto a vari√°vel <code>i</code> for menor que 5.</p>

    <h3>Cuidados com o while</h3>
    <p>√â importante garantir que a condi√ß√£o do <code>while</code> eventualmente se torne falsa, caso contr√°rio, o programa poder√° entrar em um la√ßo infinito.</p>

    <h3>Exemplo de la√ßo infinito (‚ö†Ô∏è):</h3>
    <pre><code>while (1) {
    // Este bloco ser√° executado para sempre
}</code></pre>

    <p>Loops infinitos s√£o √∫teis em algumas situa√ß√µes, como em programas que aguardam eventos, mas devem ser usados com cuidado.</p>
</div>

<!-- Cap√≠tulo 24 -->
<div id="cap24" class="chapter">
    <h2>Cap√≠tulo 24 - Estrutura DO WHILE</h2>

    <p>A estrutura <code>do while</code> √© semelhante ao <code>while</code>, mas com uma diferen√ßa importante: o bloco de c√≥digo √© executado pelo menos uma vez antes da verifica√ß√£o da condi√ß√£o.</p>

    <h3>Sintaxe do do while:</h3>
    <pre><code>do {
    // bloco de c√≥digo a ser executado
} while (condi√ß√£o);</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int i = 0;

    do {
        printf("Valor de i: %d\n", i);
        i++;
    } while (i &lt; 5);

    return 0;
}</code></pre>

    <p>No exemplo acima, o bloco de c√≥digo dentro do <code>do</code> √© executado uma vez antes da verifica√ß√£o da condi√ß√£o <code>(i &lt; 5)</code>.</p>

    <h3>Diferen√ßa entre while e do while:</h3>
    <ul>
        <li><strong>while:</strong> verifica a condi√ß√£o antes de executar o bloco.</li>
        <li><strong>do while:</strong> executa o bloco primeiro e verifica a condi√ß√£o depois.</li>
    </ul>

    <h3>Quando usar do while?</h3>
    <p>Use <code>do while</code> quando voc√™ precisar garantir que o bloco de c√≥digo ser√° executado pelo menos uma vez, como em menus de intera√ß√£o com o usu√°rio.</p>
</div>

<!-- Cap√≠tulo 25 -->
<div id="cap25" class="chapter">
    <h2>Cap√≠tulo 25 - Estruturas de Repeti√ß√£o Internas (Nested Loops)</h2>

    <p>Loops aninhados (ou nested loops) s√£o estruturas onde um loop √© colocado dentro de outro. Eles s√£o √∫teis para percorrer estruturas mais complexas, como matrizes bidimensionais.</p>

    <h3>Exemplo com for aninhado:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int linha, coluna;

    for (linha = 1; linha &lt;= 3; linha++) {
        for (coluna = 1; coluna &lt;= 5; coluna++) {
            printf("(%d,%d) ", linha, coluna);
        }
        printf("\n");
    }

    return 0;
}</code></pre>

    <p>Sa√≠da esperada:</p>
    <pre><code>(1,1) (1,2) (1,3) (1,4) (1,5)
(2,1) (2,2) (2,3) (2,4) (2,5)
(3,1) (3,2) (3,3) (3,4) (3,5)</code></pre>

    <h3>Como funciona?</h3>
    <p>Para cada itera√ß√£o do <code>for</code> externo (linhas), o <code>for</code> interno (colunas) √© executado completamente.</p>

    <h3>Aplica√ß√µes comuns:</h3>
    <ul>
        <li>Trabalhar com matrizes ou arrays 2D</li>
        <li>Constru√ß√£o de padr√µes em forma de texto</li>
        <li>Opera√ß√µes repetidas por linhas e colunas</li>
    </ul>
</div>

<!-- Cap√≠tulo 26 -->
<div id="cap26" class="chapter">
    <h2>Cap√≠tulo 26 - Break vs Continue</h2>

    <p>As instru√ß√µes <code>break</code> e <code>continue</code> s√£o usadas para controlar o fluxo de loops em C. Elas permitem alterar a sequ√™ncia normal de execu√ß√£o dentro de estruturas de repeti√ß√£o.</p>

    <h3><code>break</code></h3>
    <p>Interrompe completamente o loop atual, mesmo que a condi√ß√£o ainda seja verdadeira.</p>

    <h4>Exemplo com break:</h4>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 1; i &lt;= 10; i++) {
        if (i == 5) {
            break;
        }
        printf("%d\n", i);
    }

    return 0;
}</code></pre>

    <p><strong>Sa√≠da:</strong> O loop para ao chegar em 5.</p>
    <pre><code>1
2
3
4</code></pre>

    <h3><code>continue</code></h3>
    <p>Pula a itera√ß√£o atual do loop e continua com a pr√≥xima.</p>

    <h4>Exemplo com continue:</h4>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 1; i &lt;= 5; i++) {
        if (i == 3) {
            continue;
        }
        printf("%d\n", i);
    }

    return 0;
}</code></pre>

    <p><strong>Sa√≠da:</strong> O n√∫mero 3 ser√° ignorado.</p>
    <pre><code>1
2
4
5</code></pre>

    <h3>Resumo:</h3>
    <ul>
        <li><strong>break</strong>: Encerra o loop imediatamente.</li>
        <li><strong>continue</strong>: Pula a itera√ß√£o atual e continua o loop.</li>
    </ul>
</div>

<!-- Cap√≠tulo 27 -->
<div id="cap27" class="chapter">
    <h2>Cap√≠tulo 27 - Arrays</h2>

    <p>Um <strong>array</strong> em C √© uma cole√ß√£o de vari√°veis do mesmo tipo armazenadas em posi√ß√µes cont√≠guas de mem√≥ria. √â muito √∫til quando precisamos armazenar m√∫ltiplos valores semelhantes.</p>

    <h3>Declara√ß√£o de um array:</h3>
    <pre><code>tipo nome_array[tamanho];</code></pre>
    <p>Exemplo:</p>
    <pre><code>int numeros[5];</code></pre>

    <h3>Inicializa√ß√£o de um array:</h3>
    <pre><code>int numeros[5] = {10, 20, 30, 40, 50};</code></pre>

    <h3>Acessando elementos:</h3>
    <p>Os elementos s√£o acessados por √≠ndices, que come√ßam em 0.</p>
    <pre><code>printf("%d\n", numeros[0]); // Imprime 10
printf("%d\n", numeros[4]); // Imprime 50</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int numeros[5] = {1, 2, 3, 4, 5};

    for (int i = 0; i &lt; 5; i++) {
        printf("Elemento %d: %d\n", i, numeros[i]);
    }

    return 0;
}</code></pre>

    <h3>Sa√≠da:</h3>
    <pre><code>Elemento 0: 1
Elemento 1: 2
Elemento 2: 3
Elemento 3: 4
Elemento 4: 5</code></pre>

    <h3>Dica:</h3>
    <p>√â importante nunca acessar um √≠ndice fora do limite do array, pois isso pode causar comportamento inesperado (overflow de mem√≥ria).</p>
</div>

<!-- Cap√≠tulo 28 -->
<div id="cap28" class="chapter">
    <h2>Cap√≠tulo 28 - Mostrar um array com Estruturas de Repeti√ß√£o</h2>

    <p>Uma das formas mais eficientes de percorrer e exibir os elementos de um array √© utilizando estruturas de repeti√ß√£o, como o la√ßo <code>for</code>.</p>

    <h3>Exemplo com <code>for</code>:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int numeros[5] = {10, 20, 30, 40, 50};

    for (int i = 0; i &lt; 5; i++) {
        printf("numeros[%d] = %d\n", i, numeros[i]);
    }

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>numeros[0] = 10
numeros[1] = 20
numeros[2] = 30
numeros[3] = 40
numeros[4] = 50</code></pre>

    <h3>Exemplo com <code>while</code>:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int numeros[3] = {7, 14, 21};
    int i = 0;

    while (i &lt; 3) {
        printf("Elemento %d = %d\n", i, numeros[i]);
        i++;
    }

    return 0;
}</code></pre>

    <h3>Import√¢ncia:</h3>
    <p>La√ßos de repeti√ß√£o permitem que trabalhemos com arrays de forma din√¢mica e eficiente, especialmente quando precisamos processar ou exibir grandes quantidades de dados.</p>
</div>

<!-- Cap√≠tulo 29 -->
<div id="cap29" class="chapter">
    <h2>Cap√≠tulo 29 - Arrays 2D</h2>

    <p>Um array bidimensional (ou matriz) √© uma estrutura que representa dados em linhas e colunas, como uma tabela. √â muito √∫til para representar tabuleiros, grades, matrizes matem√°ticas e mais.</p>

    <h3>Declara√ß√£o de um array 2D:</h3>
    <pre><code>int matriz[2][3]; // 2 linhas e 3 colunas</code></pre>

    <h3>Inicializa√ß√£o de um array 2D:</h3>
    <pre><code>int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};</code></pre>

    <h3>Acessando os elementos:</h3>
    <pre><code>printf("%d", matriz[1][2]); // Imprime 6</code></pre>

    <h3>Exemplo completo:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int matriz[2][3] = {
        {10, 20, 30},
        {40, 50, 60}
    };

    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 3; j++) {
            printf("matriz[%d][%d] = %d\n", i, j, matriz[i][j]);
        }
    }

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>matriz[0][0] = 10
matriz[0][1] = 20
matriz[0][2] = 30
matriz[1][0] = 40
matriz[1][1] = 50
matriz[1][2] = 60</code></pre>

    <p>Arrays 2D s√£o fundamentais para armazenar e manipular dados em forma de grade.</p>
</div>

<!-- Cap√≠tulo 30 -->
<div id="cap30" class="chapter">
    <h2>Cap√≠tulo 30 - Arrays de String</h2>

    <p>Em C, uma string √© na verdade um array de caracteres terminado com o caractere nulo <code>'\0'</code>. Um array de strings nada mais √© do que um array de m√∫ltiplos arrays de caracteres.</p>

    <h3>Declara√ß√£o de um array de strings:</h3>
    <pre><code>char frutas[3][10] = {
    "Ma√ß√£",
    "Banana",
    "Uva"
};</code></pre>

    <h3>Exemplo completo:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    char frutas[3][10] = {
        "Ma√ß√£",
        "Banana",
        "Uva"
    };

    for (int i = 0; i &lt; 3; i++) {
        printf("Fruta %d: %s\n", i + 1, frutas[i]);
    }

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>Fruta 1: Ma√ß√£
Fruta 2: Banana
Fruta 3: Uva</code></pre>

    <p>Note que cada string pode ter at√© 9 caracteres vis√≠veis, pois o d√©cimo espa√ßo √© reservado para o caractere nulo <code>'\0'</code> que indica o fim da string.</p>
</div>

<!-- Cap√≠tulo 31 -->
<div id="cap31" class="chapter">
    <h2>Cap√≠tulo 31 - Trocar valores entre duas vari√°veis</h2>

    <p>Trocar valores entre duas vari√°veis √© uma opera√ß√£o comum em programa√ß√£o. Isso geralmente √© feito com o uso de uma vari√°vel tempor√°ria.</p>

    <h3>Exemplo usando vari√°vel tempor√°ria:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = 10;
    int temp;

    printf("Antes da troca: a = %d, b = %d\n", a, b);

    temp = a;
    a = b;
    b = temp;

    printf("Depois da troca: a = %d, b = %d\n", a, b);

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>Antes da troca: a = 5, b = 10
Depois da troca: a = 10, b = 5</code></pre>

    <h3>Alternativa sem vari√°vel tempor√°ria (usando operadores):</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = 10;

    printf("Antes da troca: a = %d, b = %d\n", a, b);

    a = a + b;
    b = a - b;
    a = a - b;

    printf("Depois da troca: a = %d, b = %d\n", a, b);

    return 0;
}</code></pre>

    <p>Embora o segundo m√©todo funcione, o uso de uma vari√°vel tempor√°ria √© mais seguro e claro para a maioria dos casos.</p>
</div>

<!-- Cap√≠tulo 32 -->
<div id="cap32" class="chapter">
    <h2>Cap√≠tulo 32 - Organizar uma array</h2>

    <p>Organizar (ou ordenar) uma array significa colocar seus elementos em uma determinada ordem, como crescente ou decrescente. O m√©todo mais simples para isso √© o algoritmo <strong>Bubble Sort</strong>.</p>

    <h3>Exemplo de ordena√ß√£o crescente usando Bubble Sort:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int array[] = {5, 2, 9, 1, 5, 6};
    int tamanho = sizeof(array) / sizeof(array[0]);
    int i, j, temp;

    for (i = 0; i &lt; tamanho - 1; i++) {
        for (j = 0; j &lt; tamanho - i - 1; j++) {
            if (array[j] &gt; array[j + 1]) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }

    printf("Array ordenado: ");
    for (i = 0; i &lt; tamanho; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>Array ordenado: 1 2 5 5 6 9</code></pre>

    <p>Existem algoritmos mais eficientes, como Quick Sort e Merge Sort, mas o Bubble Sort √© √≥timo para fins educacionais e pequenas quantidades de dados.</p>
</div>

<!-- Cap√≠tulo 33 -->
<div id="cap33" class="chapter">
    <h2>Cap√≠tulo 33 - STRUCT</h2>

    <p>Em C, uma <strong>struct</strong> (estrutura) permite agrupar diferentes tipos de dados sob um √∫nico nome. Ela √© √∫til quando voc√™ precisa representar um objeto com v√°rias caracter√≠sticas.</p>

    <h3>Sintaxe b√°sica:</h3>
    <pre><code>struct NomeDaStruct {
    tipo membro1;
    tipo membro2;
    ...
};</code></pre>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

// Definindo a struct
struct Pessoa {
    char nome[50];
    int idade;
    float altura;
};

int main() {
    struct Pessoa p1;

    // Atribuindo valores
    strcpy(p1.nome, "Ana");
    p1.idade = 28;
    p1.altura = 1.65;

    // Exibindo valores
    printf("Nome: %s\n", p1.nome);
    printf("Idade: %d\n", p1.idade);
    printf("Altura: %.2f\n", p1.altura);

    return 0;
}</code></pre>

    <h3>Sa√≠da esperada:</h3>
    <pre><code>Nome: Ana
Idade: 28
Altura: 1.65</code></pre>

    <p>Com structs, voc√™ pode modelar estruturas mais complexas no seu programa de forma organizada e reutiliz√°vel.</p>
</div>

<!-- Cap√≠tulo 34 -->
<div id="cap34" class="chapter">
    <h2>Cap√≠tulo 34 - TYPEDEF</h2>

    <p>O <strong>typedef</strong> √© uma palavra-chave usada para criar um nome alternativo (alias) para tipos de dados existentes. Ele √© muito √∫til para tornar o c√≥digo mais leg√≠vel e mais f√°cil de manter.</p>

    <h3>Exemplo simples:</h3>
    <pre><code>#include &lt;stdio.h&gt;

typedef unsigned int idade;

int main() {
    idade x = 25;
    printf("Idade: %u anos\n", x);
    return 0;
}</code></pre>

    <h3>Exemplo com struct:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Definindo um alias para struct Pessoa
typedef struct {
    char nome[50];
    int idade;
} Pessoa;

int main() {
    Pessoa p;

    strcpy(p.nome, "Carlos");
    p.idade = 35;

    printf("Nome: %s\n", p.nome);
    printf("Idade: %d\n", p.idade);

    return 0;
}</code></pre>

    <p>Com <code>typedef</code>, voc√™ pode escrever <code>Pessoa</code> diretamente, em vez de <code>struct Pessoa</code>, deixando o c√≥digo mais limpo.</p>
</div>

<!-- Cap√≠tulo 35 -->
<div id="cap35" class="chapter">
    <h2>Cap√≠tulo 35 - Array de Structs</h2>

    <p>Voc√™ pode usar <strong>arrays de structs</strong> para armazenar m√∫ltiplas estruturas do mesmo tipo. Isso √© √∫til, por exemplo, quando voc√™ precisa lidar com uma lista de pessoas, produtos, alunos, etc.</p>

    <h3>Exemplo:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Aluno {
    char nome[50];
    int idade;
};

int main() {
    struct Aluno turma[3];

    strcpy(turma[0].nome, "Ana");
    turma[0].idade = 20;

    strcpy(turma[1].nome, "Bruno");
    turma[1].idade = 22;

    strcpy(turma[2].nome, "Clara");
    turma[2].idade = 21;

    for (int i = 0; i &lt; 3; i++) {
        printf("Aluno %d:\n", i + 1);
        printf("Nome: %s\n", turma[i].nome);
        printf("Idade: %d\n\n", turma[i].idade);
    }

    return 0;
}</code></pre>

    <p>Arrays de structs permitem organizar dados complexos de forma estruturada e pr√°tica.</p>
</div>

<!-- Cap√≠tulo 36 -->
<div id="cap36" class="chapter">
    <h2>Cap√≠tulo 36 - Enums</h2>

    <p>O <strong>enum</strong> (abrevia√ß√£o de "enumeration") √© um tipo definido pelo programador que permite atribuir nomes a inteiros, tornando o c√≥digo mais leg√≠vel.</p>

    <h3>Declara√ß√£o de um enum:</h3>
    <pre><code>enum DiaDaSemana {
    DOMINGO,
    SEGUNDA,
    TERCA,
    QUARTA,
    QUINTA,
    SEXTA,
    SABADO
};</code></pre>

    <p>Por padr√£o, o primeiro valor tem o valor 0, e os seguintes incrementam em 1.</p>

    <h3>Usando enums no c√≥digo:</h3>
    <pre><code>#include &lt;stdio.h&gt;

enum DiaDaSemana {
    DOMINGO,
    SEGUNDA,
    TERCA,
    QUARTA,
    QUINTA,
    SEXTA,
    SABADO
};

int main() {
    enum DiaDaSemana hoje;

    hoje = QUARTA;

    if (hoje == QUARTA) {
        printf("Hoje √© quarta-feira!\n");
    }

    return 0;
}</code></pre>

    <p>Voc√™ tamb√©m pode atribuir valores personalizados aos elementos do enum:</p>

    <pre><code>enum Status {
    SUCESSO = 1,
    ERRO = -1
};</code></pre>

    <p>Enums tornam o c√≥digo mais organizado e ajudam a evitar o uso de n√∫meros "m√°gicos" espalhados pelo programa.</p>
</div>

<!-- Cap√≠tulo 37 -->
<div id="cap37" class="chapter">
    <h2>Cap√≠tulo 37 - N√∫meros Aleat√≥rios</h2>

    <p>Em C, voc√™ pode gerar n√∫meros aleat√≥rios usando a fun√ß√£o <code>rand()</code>, que est√° dispon√≠vel na biblioteca <code>&lt;stdlib.h&gt;</code>.</p>

    <h3>Exemplo b√°sico:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int numero = rand();  // N√∫mero aleat√≥rio
    printf("N√∫mero aleat√≥rio: %d\n", numero);
    return 0;
}</code></pre>

    <p>No entanto, para que os valores sejam diferentes a cada execu√ß√£o, usamos <code>srand()</code> com <code>time(NULL)</code> como semente.</p>

    <h3>Exemplo com semente:</h3>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    srand(time(NULL));  // Define a semente com o tempo atual

    int aleatorio = rand() % 100;  // Gera n√∫mero de 0 a 99
    printf("N√∫mero aleat√≥rio entre 0 e 99: %d\n", aleatorio);
    return 0;
}</code></pre>

    <p>Voc√™ pode ajustar a faixa usando:</p>
    <pre><code>int aleatorio = (rand() % (max - min + 1)) + min;</code></pre>

    <p>Isso garante que o n√∫mero gerado esteja entre <code>min</code> e <code>max</code> (inclusive).</p>

    <h3>Importante:</h3>
    <ul>
        <li>Use <code>srand(time(NULL))</code> apenas uma vez no <code>main()</code>.</li>
        <li>Sem <code>srand()</code>, o <code>rand()</code> gerar√° os mesmos n√∫meros toda vez que o programa for executado.</li>
    </ul>
</div>

<!-- Cap√≠tulo 38 -->
<div id="cap38" class="chapter">
    <h2>Cap√≠tulo 38 ‚Äì Operadores Bitwise</h2>

    <p>Os operadores bitwise permitem a manipula√ß√£o direta dos bits dos n√∫meros inteiros. Eles s√£o √∫teis para otimiza√ß√£o de desempenho, programa√ß√£o de sistemas, criptografia, compress√£o de dados, entre outros.</p>

    <h3>Operadores dispon√≠veis em C:</h3>
    <table>
        <tr>
            <th>Operador</th>
            <th>Descri√ß√£o</th>
            <th>Exemplo</th>
        </tr>
        <tr>
            <td>&</td>
            <td>AND bit a bit</td>
            <td>a & b</td>
        </tr>
        <tr>
            <td>|</td>
            <td>OR bit a bit</td>
            <td>a | b</td>
        </tr>
        <tr>
            <td>^</td>
            <td>XOR bit a bit (OU exclusivo)</td>
            <td>a ^ b</td>
        </tr>
        <tr>
            <td>~</td>
            <td>NOT bit a bit (complemento)</td>
            <td>~a</td>
        </tr>
        <tr>
            <td>&lt;&lt;</td>
            <td>Deslocamento √† esquerda</td>
            <td>a &lt;&lt; 1</td>
        </tr>
        <tr>
            <td>&gt;&gt;</td>
            <td>Deslocamento √† direita</td>
            <td>a &gt;&gt; 1</td>
        </tr>
    </table>

    <h3>Exemplo pr√°tico:</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = 6; // 00000110
    int b = 3; // 00000011

    printf("a & b = %d\n", a & b);
    printf("a | b = %d\n", a | b);
    printf("a ^ b = %d\n", a ^ b);
    printf("~a = %d\n", ~a);
    printf("a &lt;&lt; 1 = %d\n", a &lt;&lt; 1);
    printf("a &gt;&gt; 1 = %d\n", a &gt;&gt; 1);

    return 0;
}</code></pre>

    <h3>Resumo:</h3>
    <ul>
        <li><strong>&</strong> ‚Äì Retorna 1 se ambos os bits forem 1</li>
        <li><strong>|</strong> ‚Äì Retorna 1 se pelo menos um dos bits for 1</li>
        <li><strong>^</strong> ‚Äì Retorna 1 se os bits forem diferentes</li>
        <li><strong>~</strong> ‚Äì Inverte todos os bits</li>
        <li><strong>&lt;&lt;</strong> ‚Äì Move os bits para a esquerda (multiplica por 2 a cada deslocamento)</li>
        <li><strong>&gt;&gt;</strong> ‚Äì Move os bits para a direita (divide por 2 a cada deslocamento)</li>
    </ul>
</div>

<!-- Cap√≠tulo 39 -->
<div id="cap39" class="chapter">
    <h2>Cap√≠tulo 39 - Endere√ßos de Mem√≥ria</h2>

    <p>Em C, cada vari√°vel √© armazenada em um endere√ßo espec√≠fico da mem√≥ria do computador. Compreender como acessar e utilizar esses endere√ßos √© essencial para trabalhar com ponteiros, otimiza√ß√£o de c√≥digo e manipula√ß√£o de dados em baixo n√≠vel.</p>

    <h3>O operador <code>&</code></h3>
    <p>O operador <code>&</code> √© utilizado para obter o endere√ßo de mem√≥ria de uma vari√°vel.</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 25;
    printf("Valor da vari√°vel: %d\n", idade);
    printf("Endere√ßo de mem√≥ria: %p\n", &idade);
    return 0;
}</code></pre>

    <p>O especificador <code>%p</code> √© usado com <code>printf</code> para exibir um endere√ßo de mem√≥ria.</p>

    <h3>Por que isso √© √∫til?</h3>
    <ul>
        <li>Permite a manipula√ß√£o de vari√°veis por refer√™ncia</li>
        <li>√â fundamental para trabalhar com ponteiros</li>
        <li>Ajuda a entender como a mem√≥ria √© usada pelo programa</li>
    </ul>

    <h3>Visualizando o endere√ßo de diferentes tipos</h3>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    int inteiro = 10;
    float decimal = 3.14;
    char letra = 'A';

    printf("Endere√ßo de inteiro: %p\n", &inteiro);
    printf("Endere√ßo de float: %p\n", &decimal);
    printf("Endere√ßo de char: %p\n", &letra);

    return 0;
}</code></pre>

    <p>Note que cada tipo ocupa um espa√ßo diferente na mem√≥ria, e os endere√ßos podem variar dependendo da arquitetura do computador.</p>
</div>

<!-- Cap√≠tulo 40 -->
<div id="cap40" class="chapter">
    <h2>Cap√≠tulo 40 - Ponteiros</h2>

    <p>Ponteiros s√£o vari√°veis que armazenam o endere√ßo de mem√≥ria de outras vari√°veis. Eles s√£o uma das caracter√≠sticas mais poderosas da linguagem C.</p>

    <h3>Declara√ß√£o de Ponteiros</h3>
    <p>Para declarar um ponteiro, utilizamos o s√≠mbolo <code>*</code> antes do nome da vari√°vel:</p>

<pre><code>int *ptr; // Ponteiro para um inteiro</code></pre>

    <h3>Utilizando ponteiros</h3>
    <p>Vamos ver um exemplo de como declarar, atribuir e acessar um valor usando ponteiros:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int idade = 30;
    int *p;

    p = &idade; // ponteiro 'p' recebe o endere√ßo da vari√°vel 'idade'

    printf("Valor de idade: %d\n", idade);
    printf("Endere√ßo de idade: %p\n", &idade);
    printf("Valor armazenado em p (endere√ßo): %p\n", p);
    printf("Valor apontado por p: %d\n", *p); // acessa o valor usando o ponteiro

    return 0;
}</code></pre>

    <h3>Explica√ß√£o dos s√≠mbolos</h3>
    <ul>
        <li><strong>&</strong> ‚Äì operador de endere√ßo (retorna o endere√ßo de uma vari√°vel)</li>
        <li><strong>*</strong> ‚Äì operador de desreferencia√ß√£o (acessa o valor armazenado no endere√ßo)</li>
    </ul>

    <h3>Por que usar ponteiros?</h3>
    <ul>
        <li>Permite passagem de par√¢metros por refer√™ncia em fun√ß√µes</li>
        <li>√ötil para trabalhar com arrays e strings</li>
        <li>Fundamental para aloca√ß√£o din√¢mica de mem√≥ria</li>
    </ul>
</div>

<!-- Cap√≠tulo 41 -->
<div id="cap41" class="chapter">
    <h2>Cap√≠tulo 41 - Criando Arquivos</h2>

    <p>Em C, podemos criar e escrever arquivos utilizando as fun√ß√µes da biblioteca <code>stdio.h</code>. Isso √© √∫til para salvar dados de programas, gerar relat√≥rios, entre outras aplica√ß√µes.</p>

    <h3>Abrindo um arquivo para escrita</h3>
    <p>Utilizamos a fun√ß√£o <code>fopen()</code> com o modo <code>"w"</code> para criar um novo arquivo ou sobrescrever um existente:</p>

<pre><code>FILE *arquivo;

arquivo = fopen("dados.txt", "w");

if (arquivo == NULL) {
    printf("Erro ao criar o arquivo!\n");
    return 1;
}
</code></pre>

    <h3>Escrevendo no arquivo</h3>
    <p>Podemos usar a fun√ß√£o <code>fprintf()</code> para escrever dados no arquivo:</p>

<pre><code>fprintf(arquivo, "Nome: Jo√£o\nIdade: 25\n");</code></pre>

    <h3>Fechando o arquivo</h3>
    <p>Sempre feche o arquivo ap√≥s terminar a escrita com <code>fclose()</code>:</p>

<pre><code>fclose(arquivo);</code></pre>

    <h3>Exemplo completo</h3>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    FILE *arquivo;

    arquivo = fopen("dados.txt", "w");

    if (arquivo == NULL) {
        printf("Erro ao criar o arquivo!\n");
        return 1;
    }

    fprintf(arquivo, "Nome: Jo√£o\n");
    fprintf(arquivo, "Idade: 25\n");

    fclose(arquivo);

    printf("Arquivo criado com sucesso!\n");

    return 0;
}</code></pre>

    <h3>Modos de abertura de arquivo</h3>
    <ul>
        <li><code>"w"</code> ‚Äì escrita (cria ou sobrescreve)</li>
        <li><code>"a"</code> ‚Äì anexar ao final (sem apagar o conte√∫do existente)</li>
        <li><code>"r"</code> ‚Äì leitura (arquivo deve existir)</li>
    </ul>

    <p>Agora que sabemos criar arquivos, no pr√≥ximo cap√≠tulo podemos aprender a <strong>ler arquivos</strong>.</p>
</div>

<!-- Cap√≠tulo 42 -->
<div id="cap42" class="chapter">
    <h2>Cap√≠tulo 42 - Lendo Arquivos</h2>

    <p>Depois de criar arquivos, tamb√©m precisamos saber como <strong>ler</strong> dados deles. Em C, usamos fun√ß√µes como <code>fopen()</code>, <code>fgetc()</code>, <code>fgets()</code> e <code>fscanf()</code> para ler o conte√∫do de arquivos.</p>

    <h3>Abrindo um arquivo para leitura</h3>
    <p>Use o modo <code>"r"</code> na fun√ß√£o <code>fopen()</code> para abrir o arquivo somente para leitura:</p>

<pre><code>FILE *arquivo;

arquivo = fopen("dados.txt", "r");

if (arquivo == NULL) {
    printf("Erro ao abrir o arquivo!\n");
    return 1;
}
</code></pre>

    <h3>Lendo com fgetc()</h3>
    <p>A fun√ß√£o <code>fgetc()</code> l√™ um caractere por vez:</p>

<pre><code>char c;

while ((c = fgetc(arquivo)) != EOF) {
    printf("%c", c);
}</code></pre>

    <h3>Lendo com fgets()</h3>
    <p>Podemos ler uma linha inteira com <code>fgets()</code>:</p>

<pre><code>char linha[100];

while (fgets(linha, sizeof(linha), arquivo) != NULL) {
    printf("%s", linha);
}</code></pre>

    <h3>Lendo com fscanf()</h3>
    <p>Tamb√©m √© poss√≠vel ler dados formatados com <code>fscanf()</code>:</p>

<pre><code>char nome[50];
int idade;

fscanf(arquivo, "Nome: %s\n", nome);
fscanf(arquivo, "Idade: %d\n", &idade);

printf("Nome: %s\nIdade: %d\n", nome, idade);</code></pre>

    <h3>Fechando o arquivo</h3>
    <p>N√£o se esque√ßa de fechar o arquivo:</p>

<pre><code>fclose(arquivo);</code></pre>

    <h3>Exemplo completo com fgets()</h3>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    FILE *arquivo;
    char linha[100];

    arquivo = fopen("dados.txt", "r");

    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo!\n");
        return 1;
    }

    while (fgets(linha, sizeof(linha), arquivo) != NULL) {
        printf("%s", linha);
    }

    fclose(arquivo);
    return 0;
}</code></pre>

    <p>Agora que j√° sabemos criar e ler arquivos, estamos prontos para avan√ßar para opera√ß√µes mais avan√ßadas com arquivos, como atualiza√ß√£o de dados!</p>
</div>

<script src="script.js"></script>
</body>
</html>
